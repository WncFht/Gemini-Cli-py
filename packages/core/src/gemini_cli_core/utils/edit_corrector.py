"""
This file is refactored from packages/core_ts/src/utils/editCorrector.ts.
It provides functions to correct potentially erroneous edits generated by the LLM.
"""

import logging
import re
from functools import lru_cache
from typing import Any

from pydantic import BaseModel

from gemini_cli_core.core.app import GeminiClient
from gemini_cli_core.tools.file.edit_file import EditToolParams

logger = logging.getLogger(__name__)


class CorrectedEditResult(BaseModel):
    params: EditToolParams
    occurrences: int


@lru_cache(maxsize=128)
def unescape_string_for_gemini_bug(input_string: str) -> str:
    """Fixes specific escaping errors in LLM-generated strings."""
    return re.sub(
        r'\\+(n|t|r|\'|"|`|\\)',
        lambda m: m.group(1).encode().decode("unicode_escape"),
        input_string,
    )


def count_occurrences(text: str, sub: str) -> int:
    """Counts non-overlapping occurrences of a substring."""
    return text.count(sub) if sub else 0


async def correct_old_string_mismatch(
    client: GeminiClient, file_content: str, problematic_snippet: str
) -> str:
    """Uses an LLM to correct a mismatched old_string."""
    prompt = f"""Analyze the file content and the problematic snippet. Identify the most likely part of the file that the snippet was intended to match. Output the exact, literal text from the file that corresponds to the snippet. Focus on correcting escape characters, formatting, or slight variations.

Problematic Snippet:
```
{problematic_snippet}
```

File Content:
```
{file_content}
```

Respond with a JSON object: {{"corrected_target_snippet": "..."}}
"""
    try:
        response = await client.generate_json(
            contents=[{"role": "user", "parts": [{"text": prompt}]}],
            schema={
                "type": "object",
                "properties": {"corrected_target_snippet": {"type": "string"}},
            },
            abort_signal=None,  # No easy way to pass signal through decorator yet
        )
        return response.get("corrected_target_snippet", problematic_snippet)
    except Exception:
        logger.warning(
            "LLM call for old_string correction failed.", exc_info=True
        )
        return problematic_snippet


async def correct_new_string(
    client: GeminiClient,
    original_old: str,
    corrected_old: str,
    original_new: str,
) -> str:
    """Adjusts the new_string to align with the corrected old_string."""
    # Simplified logic, as this is complex to get right.
    # A full implementation would require a more sophisticated diff-patch approach.
    return unescape_string_for_gemini_bug(original_new)


async def ensure_correct_edit(
    current_content: str,
    original_params: EditToolParams,
    client: GeminiClient,
    signal: Any,
) -> CorrectedEditResult:
    """
    Ensures edit parameters are correct, attempting to fix them if necessary.
    This is a simplified port of the complex JS logic.
    """
    final_old = unescape_string_for_gemini_bug(original_params.old_string)
    final_new = unescape_string_for_gemini_bug(original_params.new_string)

    occurrences = count_occurrences(current_content, final_old)

    if occurrences == 0 and final_old:
        corrected_old = await correct_old_string_mismatch(
            client, current_content, final_old
        )
        occurrences = count_occurrences(current_content, corrected_old)
        if occurrences > 0:
            final_old = corrected_old
            # For simplicity, we just unescape new_string here. A more complex
            # correction would be needed for perfect alignment.
            final_new = await correct_new_string(
                client,
                original_params.old_string,
                final_old,
                original_params.new_string,
            )

    return CorrectedEditResult(
        params=EditToolParams(
            file_path=original_params.file_path,
            old_string=final_old,
            new_string=final_new,
            expected_replacements=original_params.expected_replacements,
        ),
        occurrences=occurrences,
    )


async def ensure_correct_file_content(
    content: str, client: GeminiClient, signal: Any
) -> str:
    """Ensures a new file's content is correctly unescaped."""
    return unescape_string_for_gemini_bug(content)
